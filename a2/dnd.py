"""
Function to simulate a text-based Dungeons and Dragons game.
"""
import doctest
import random


def roll_die(number_of_rolls, number_of_sides):
    """Die rolling simulator
    This function simulator the process of rolling a die, return the sum of the individual rolls.

     Computational Thinking:
    1) Decomposition: use random.randint random generate an integer within the limit as the point of each roll;
                      use while loop to adds up all the points as a result of the  sum of the points from all the rolls.
    2) Algorithms: use while loop to calculate the sum of the points, the count starts at zero,
                   the sum of the points starts at zero. Loop ends when the count reaches the number of rolls required,
                   randomly generate a positive non-zero integer with upper limit (number of sides),
                   when we generate a point for one roll around, the count goes up by 1,
                   point adds to the sum of the points.
    3) Generalization: this logic can be used for other questions that randomly generated a result, and added up the
                        results together.

    :param number_of_rolls: a positive non-zero integer.
    :param number_of_sides: a positive non-zero integer.
    :precondition: number_of_rolls and number_of_sides must be positive non-zero integers.
    :postcondition: return the sum of the individual rolls.
    :return: the sum of the individual rolls as an integer.
    """

    # use while loop to calculate the sum of the points
    # count start at zero
    count = 0
    # the sum of the points starts at zero
    roll_sum = 0

    # loop ends when count reaches the number of rolls required
    while count < number_of_rolls:
        # random generate a positive non-zero integer with upper limit (number of sides)
        roll_result = random.randint(1, number_of_sides)
        # when we generate a point for one roll around, count goes up by 1
        count += 1
        # point adds to the sum of the points
        roll_sum += roll_result
    return roll_sum


def generate_vowel():
    """ Random vowel generator

    Computational Thinking:
    1) Decomposition: form a vowel list containing all the vowels;
                      use random choice to random select a letter from the vowel list.
    2) Algorithms: use the properties of the list and random function, create the vowel list containing all the vowels
                   as the range of the random selection, then use the random choice function to randomly select a letter
                   from the vowel list.

    :postcondition: randomly select a single vowel.
    :return: a randomly selected single vowel as a string.
    """
    # create the vowel list containing all the vowels
    vowel_list = ['a', 'e', 'i', 'o', 'u', 'y']

    # random select a vowel from the above vowel list
    vowel_result = random.choice(vowel_list)
    return vowel_result


def generate_consonant():
    """ Random consonant generator

    Computational Thinking:
    1) Decomposition: form a consonant list containing all the consonants;
                      use random choice to random select a letter from the consonant list.
    2) Pattern matching: similar logic to convert_to_roman_numeral() above,
                         use random function to random select a letter from the given list.
    3) Algorithms: use the properties of the list and random function, create the consonant list containing all the
                   consonants as the range of the random selection, then use the random choice function to randomly
                   select a letter from the consonant list.

    :postcondition: randomly select a single consonant.
    :return: a randomly selected single consonant as a string.
    """
    # create the consonant list containing all the consonants
    consonant_list = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',
                      'p', 'q', 'r', 's', 't', 'v', 'x', 'z', 'w', 'y']

    # random select a consonant from the above consonant list
    consonant_result = random.choice(consonant_list)
    return consonant_result


def generate_syllable():
    """ Syllable generator
    Generate a two-lettered syllable by joining the random consonant generated by generate_consonant()
    and the random vowel generated by generate_vowel().

    Computational Thinking:
    1) Decomposition: combine the result generated by generate_consonant() and generate_vowel() to form a two lettered
                      syllable.
    2) Algorithms: use the properties of strings, generate_consonant() can generate a consonant string, generate_vowel()
                   can generate a vowel string. These two strings can be combined by '+' operation.

    :precondition: the random consonant must be generated by generate_consonant(),
                   and the random vowel must be generated by generate_vowel().
    :postcondition: concatenate the consonant and vowel in this exact order, to a two-letter syllable as a string.
    :return: the correctly concatenate two-letter syllable as a string.
    """
    # combine one consonant with one vowel
    syllable_result = generate_consonant() + generate_vowel()
    return syllable_result


def generate_name(syllables):
    """ Name generator
    Generate a name by joining a certain number of two-lettered syllables generated by generate_syllable().

    Computational Thinking:
    1) Decomposition: use the randomly generated syllables from generate_syllable();
                      use while loop to combine all the syllables as a name;
                      modify the resulted name to a proper format.
    2ï¼‰Patten matching: similar logic to roll_die function above, use while loop to combine
                       the result generated by each loop.
    3) Algorithms: use the while loop to combine all the generated syllables together to a name, count start at zero.
                   every time it generated a new syllable and join it to the existing syllables, count goes up by one,
                   loop ends when the count reach the syllables required. Capitalize the  generated name to the proper
                   name format.

    :param syllables: a positive integer.
    :precondition: syllables must be a positive non-zero integer.
    :postcondition: generate a name composed of the specified number of two-lettered syllables.
    :return: correctly generate a name composed of the specified number of two-lettered syllables as a string
    """

    # use the while loop to combine all the generated syllables together to a name
    # count start at zero
    count = 0
    name_result = ''

    # loop ends when the count reach the syllables required
    while count < syllables:
        syllables_generated = generate_syllable()
        name_result += syllables_generated
        # every time it generated a new syllable and join it to the existing syllables, count goes up by one
        count += 1
    return name_result.capitalize()


def create_character(syllables):
    """ Create a Dungeons and Dragons character

    Computational Thinking:
    1) Decomposition: promote error message if player enters an invalid input;
                      form a character dictionary containing all character information;
                      modify the character dictionary base on the choice  the player made.
    2) Algorithms: use the properties of the dictionary, form the a dictionary that contains all the character
                   information called character. Within the dictionary, creates key-value pair containing character
                   information. Character name is generated by generate_name function, character strength, intelligence,
                   wisdom, dexterity, constitution, charisma is generated by roll_die function. Hard-coding character
                   information of inventory and experience points. Use select_class and select_race functions to generate
                   player's class and race. Add character HP to the character information dictionary according to the
                   class the player chosen. HP includes max HP and current HP, they are equal at the beginning of the
                   game. The value of HP is generated by the the roll_die function.

    :param syllables: a positive integer.
    :precondition: syllables must be a positive non-zero integer.
    :postcondition: return a dictionary which represents the character.
    :return: correctly return a Dungeons and Dragons character as a dictionary.
    """
    if type(syllables) != int:
        # check if the type of the syllables is not a integer
        print("Warning: this is not a correct input, please enter a positive integer.")
        return None
    elif syllables <= 0:
        # check if syllables is a positive non-zero integer
        print("Warning: this is not a correct input, please enter a positive integer.")
        return None
    else:
        # when syllables is a positive non-zero integer
        # form the a dictionary that contains all the character information called character
        character = {
            'Name': generate_name(syllables),
            'Strength': roll_die(3, 6),  # roll three six-sided dice
            'Intelligence': roll_die(3, 6),
            'Wisdom': roll_die(3, 6),
            'Dexterity': roll_die(3, 6),
            'Constitution': roll_die(3, 6),
            'Charisma': roll_die(3, 6),
            'inventory': [],
            'experience points': 0,
            'class': select_class(),
            'Race': select_race(),
        }

        # add the HP to the character information dictionary according to the class the player chosen
        if character['class'] == 'Barbarian':
            max_hp = roll_die(1, 12)
            current_hp = max_hp
            character['HP'] = [max_hp, current_hp]
        elif character['class'] == 'Fighter' or character['class'] == 'Paladin' or character['class'] == 'Ranger':
            max_hp = roll_die(1, 10)
            current_hp = max_hp
            character['HP'] = [max_hp, current_hp]
        elif character['class'] == 'Sorcerer' or character['class'] == 'Wizard':
            max_hp = roll_die(1, 6)
            current_hp = max_hp
            character['HP'] = [max_hp, current_hp]
        else:
            max_hp = roll_die(1, 8)
            current_hp = max_hp
            character['HP'] = [max_hp, current_hp]

    return character


def select_class():
    """ Select a class
    Select a class for player's character from the twelve classes in Dungeons & Dragons.

    Computational Thinking:
    1) Decomposition: create a dictionary that contains all classes in the Dungeons & Dragons world to corresponding
                      number; create a while loop that force the player to enter the correct number of the corresponding
                      class.
    2) Algorithms: use the properties of the dictionary, creates key-value pairs of numbers and corresponding classes.
                   create a while loop that force the player to enter the correct number of the corresponding class.
                   Ask the user for input, if player enter the invalid input, the loop will continue until they enter
                   the valid input. This  function will return the corresponding class according to the number that
                   user entered, and loop ends.
    3) Generalizationï¼šthis logic can be used with similar questions that keep asking the user to enter the inputs, until
                       certain condition to break the loop.

    :precondition: player must enter a positive integer between 1 to 12.
    :postcondition: prints out a list of classes to the player and asks the player to select the class they want to play
    :return: the race that the player desired as a string
    """
    # form a dictionary that contains all classes in the Dungeons & Dragons world to corresponding number
    class_dictionary = {
        '1': 'Barbarian',
        '2': 'Bard',
        '3': 'Cleric',
        '4': 'Druid',
        '5': 'Fighter',
        '6': 'Monk',
        '7': 'Paladin',
        '8': 'Ranger',
        '9': 'Rogue',
        '10': 'Sorcerer',
        '11': 'Warlock',
        '12': 'Wizard'
    }
    # create a while loop that force the player to enter the correct number of the corresponding class
    while True:
        print("Please choose your class! ")
        # print the pairs in the dictionary for better visual display
        for x, y in class_dictionary.items():
            print(x, y)
        player_num = str(input("please enter the number of the class you desired: ").strip())
        # when player enter the valid input, the number that pair with the corresponding class, the loop will stop
        if player_num in class_dictionary:
            player_class = class_dictionary[player_num]
            return player_class
        # if player enter the invalid input, the loop will continue until they enter the valid input
        else:
            continue


def select_race():
    """ Select a race
    Select a race for player's character from the nine classes in Dungeons & Dragons.

    Computational Thinking:
    1) Decomposition: create a dictionary that contains all races in the Dungeons & Dragons world to corresponding
                      number; create a while loop that force the player to enter the correct number of the corresponding
                      race.
    2ï¼‰Patten matching: similar logic to the select_class() function above.
    3) Algorithms: use the properties of the dictionary, creates key-value pairs of numbers and corresponding races.
                   create a while loop that force the player to enter the correct number of the corresponding race.
                   Ask the user for input, if player enter the invalid input, the loop will continue until they enter
                   the valid input. This  function will return the corresponding race according to the number that
                   user entered, and loop ends.
    4) Generalizationï¼šthis logic can be used with similar questions that keep asking the user to enter the inputs, until
                       certain condition to break the loop.

    :precondition: player must enter a positive integer between 1 to 9.
    :postcondition: prints out a list of races to the player and asks the player to select the race they want to play
    :return: the race that the player desired as a string
    """
    # form a dictionary that contains all races in the Dungeons & Dragons world to corresponding number
    my_dictionary = {
        '1': 'Dragonborn',
        '2': 'Dwarf',
        '3': 'Elf',
        '4': 'Gnome',
        '5': 'Half-Elf',
        '6': 'Halfling',
        '7': 'Half-Orc',
        '8': 'Human',
        '9': 'Tiefling'
    }
    # create a while loop that force the player to enter the correct number of the corresponding race
    while True:
        print("Please choose your race! ")
        # print the pairs in the dictionary for better visual display
        for x, y in my_dictionary.items():
            print(x, y)
        player_num = str(input("please enter the number of the race you desired: ").strip())
        # when player enter the valid input, the number that pair with the corresponding race, the loop will stop
        if player_num in my_dictionary:
            player_race = my_dictionary[player_num]
            return player_race
        # if player enter an invalid input, the loop will continue until they enter the valid input
        else:
            continue


def print_character(character):
    """Print character information
    This function print a list of the character's information which is generated by the create_character function.

    Computational Thinking:
    1) Decomposition: print the key-value pairs within the character dictionary vertically.
    2) Algorithms: use the properties of the dictionary, create a for loop that print the 'key' and the corresponding
                   'value' one by one.
    4) Generalizationï¼šuse the same approach to modify the key-value pairs of other dictionaries.

    :param character:a list formatted by the create_character function.
    :precondition: character must be formed my the the create_character function.
    :postcondition: print the character list formatted by the create_character function.

    >>> character_input = {'Name': 'Du','Strength': 3,'Intelligence': 3,'Wisdom': 3,'Dexterity': 3,'Constitution': 3,'Charisma': 3,'inventory': [],'experience points': 0,'class': 'Rogue','Race': 'Dragonborn','HP': [7, 7]}
    >>> print_character(character_input)
    Name Du
    Strength 3
    Intelligence 3
    Wisdom 3
    Dexterity 3
    Constitution 3
    Charisma 3
    inventory []
    experience points 0
    class Rogue
    Race Dragonborn
    HP [7, 7]

    >>> character_input = {'Name': 'Somi','Strength': 10,'Intelligence': 5,'Wisdom': 13,'Dexterity': 9,'Constitution': 12,'Charisma': 9,'inventory': [],'experience points': 0,'class': 'sorcerer','Race': 'Elf','HP': [6, 6]}
    >>> print_character(character_input)
    Name Somi
    Strength 10
    Intelligence 5
    Wisdom 13
    Dexterity 9
    Constitution 12
    Charisma 9
    inventory []
    experience points 0
    class sorcerer
    Race Elf
    HP [6, 6]

    >>> character_input = {'Name': 'Dubibi','Strength': 18,'Intelligence': 18,'Wisdom': 18,'Dexterity': 18,'Constitution': 18,'Charisma': 18,'inventory': ['sword'],'experience points': 0,'class': 'Barbarian','Race': 'Tiefling','HP': [12, 12]}
    >>> print_character(character_input)
    Name Dubibi
    Strength 18
    Intelligence 18
    Wisdom 18
    Dexterity 18
    Constitution 18
    Charisma 18
    inventory ['sword']
    experience points 0
    class Barbarian
    Race Tiefling
    HP [12, 12]


    """
    # print the pairs within the character dictionary vertically for better visual display
    for x, y in character.items():
        print(x, y)


def choose_inventory(character):
    """Choose inventory items
    This function prints a list of goods to the screen and ask the player what they want to buy.

    Computational Thinking:
    1) Decomposition: create a dictionary that contains all items in the inventory to corresponding
                      numbers; create a while loop that force the player to enter the correct number of the corresponding
                      items; player can only break the loop when enter -1.
    2) Pattern matching: similar logic to the select_class() function above.
    3) Algorithms: create a dictionary that containing all the inventory items, create an empty list, which is the
                   actual inventory list of the player. Create a while loop to ask the player to buy the things they
                   desired until they enter -1 to exit the loop (shopping). Within each loop, print the guiding
                   information of the store, when the player enter the valid input which exist in the
                   inventory_dictionary, the corresponding item will be added the player inventory list. If the player
                   enters an invalid input, an error message will be print and the loop will force the player to enter
                   the valid input in  order to proceed the game.

    :param character:a list formatted by the create_character function.
    :precondition: character must be well formatted by the create_character function.
    :postcondition: must print a list of goods to the screen and ask the player what they want to buy.
    """
    # create a variable that containing all the guiding information
    menu = ("Welcome to the Olde Tyme Merchant!\n"
            " \n"
            "Here is what we have for sale:\n"
            " \n"
            "1. sword\n"
            "2. dagger\n"
            "3. Iris(sword)\n"
            "4. a stack of cash from Rihanna\n"
            "5. Black Unicorn Relic Steel Sword\n"
            "6. Flamethrower\n"
            "7. W870 Shotgun\n"
            "8. marioâ€˜s hat\n"
            "9. Silence Glaive\n"
            "10.Crystal Carillon")

    # create a dictionary that containing all the inventory items
    inventory_dictionary = {
        '1': 'sword',
        '2': 'dagger',
        '3': 'Iris(sword)',
        '4': 'a stack of cash from Rihanna',
        '5': 'Black Unicorn Relic Steel Sword',
        '6': 'Flamethrower',
        '7': 'W870 Shotgun',
        '8': 'marioâ€˜s hat',
        '9': 'Silence Glaive',
        '10': 'Crystal Carillon',
    }

    # the actual inventory list of the player
    inventory_list = []

    # create a while loop to ask the player to buy the things they desired until they enter -1 to exit the loop (shopping)
    while True:
        print(menu)
        player_select = input("What would you like to buy (-1 to finish):\n").strip()
        # when the player enter the valid input which exist in the inventory_dictionary
        # the corresponding item will be added the player inventory list
        if player_select in inventory_dictionary:
            inventory_list.append(inventory_dictionary[player_select])
        # the player can enter -1 to terminate the shopping event
        elif player_select == '-1':
            character['inventory'] = inventory_list
            break
        # if the player enters an invalid input
        # error message will be print and the loop will force the player to enter the valid input in  order to
        # proceed the game
        else:
            print("You are asking for something we do not carry, want to choose again?")
            continue


def combat_round(opponent_one, opponent_two):
    """ Simulate a round of combat
    This function represents a single round of combat, each combatants gets a turn to do something during a
    single round of combat.

    Computational Thinking:
    1) Decomposition: create a while loop to let the players to roll different points; pass the attacker and defender
                      order ro the attack function to determine the combat result.
    2) Pattern matching: the logic is similar to the select_class function above.
    3) Algorithms: create a while loop to force the players to roll different pointsï¼Œif the players rolls the same point
                  make them roll repeatedly until they rolled different points. the loop stops when the players roll
                  different points. When player 1 rolls a higher number than player2, player1 will attack first,
                  and vise versa.
    4) Generalization: same logic when the roll of attacker and defender switched.

    :param opponent_one: a well-formed dictionaries containing a correct character
    :param opponent_two: a well-formed dictionaries containing a correct character
    :precondition: both parameters must be well-formed dictionaries that each containing a correct character
    :postcondition: the modified opponent_one and opponent_two as two separated dictionaries.
    """
    # create a while loop to force the players to roll different points
    while True:
        opponent_one_roll = roll_die(1, 20)
        opponent_two_roll = roll_die(1, 20)
        # if the players rolls the same point
        # make them repeatedly roll repeat until they rolled different points
        if opponent_one_roll == opponent_two_roll:
            continue
        else:
            # when player 1 rolls a higher number than player2, player1 will attack first
            if opponent_one_roll > opponent_two_roll:
                attack(opponent_one, opponent_two)
            # when player 2 rolls a higher  number than player1, player 2 will attack first
            elif opponent_two_roll > opponent_one_roll:
                attack(opponent_two, opponent_one)
        # the loop stops when the players roll different points
        break


def attack(attacker, defender):
    """ Initiate attack action

    Computational Thinking:
    1) Decomposition: the result of the attack functions are: 1) player1 player2 both missed; 2) player one missed,
                    player two fight back, player one died; 3) player one missed, player two fight back, player one alive;
                    4) player one attacked, player two died; 5) player one attack, player two alive, player two fight back,
                    player two missed; 6) player one attack, player two alive, player two fight back, player one died;
                    7) player one attack, player two alive, player two fight back, player one alive.
    2) Pattern matching: decision making.
    3) Algorithms: use a series of decision making events to find the result of different consequence, modify the
                  character information(HP) within the character dictionary during the attack.
    4) Generalization: same logic when the role of player one and player two switched.

    :param attacker: a well-formed dictionaries containing a correct character.
    :param defender: a well-formed dictionaries containing a correct character.
    :precondition: both parameters must be well-formed dictionaries that each containing a correct character.
    :postcondition: the modified opponent_one and opponent_two as two separated dictionaries.
    """
    if attacker['HP'][1] > 0:
        # attacker roll die once to determine hit point
        attacker_roll = roll_die(1, 20)
        print(attacker['Name'], 'is attacking', defender['Name'], 'by', attacker_roll)

        # if attacker hit point is bigger than defender Dexterity point
        # attacker's hit point will be subtracts from the defender's current HP
        if attacker_roll > defender['Dexterity']:
            defender['HP'][1] -= attacker_roll

            # when defender's current HP falls below zero, defender is died
            if defender['HP'][1] <= 0:
                print(defender['Name'], 'is dead')
                defender['HP'][1] = 0

            # when defender's current HP is larger than zero, defender will fight back
            else:
                print(defender['Name'], 'still alive')
                # defender roll die once to determine hit point
                defender_roll = roll_die(1, 20)
                print(defender['Name'], 'is going to attack by', defender_roll)
                # if defender's hit point is bigger than the attacker's dexterity point
                # defender's hit point will be subtracted from the attacker's current HP
                if defender_roll > attacker['Dexterity']:
                    attacker['HP'][1] -= defender_roll

                    # when attacker's current HP falls below zero, attacker is died
                    if attacker['HP'][1] <= 0:
                        print(attacker['Name'], 'is dead')
                        attacker['HP'][1] = 0

                    # when defender's current HP is larger than zero, attacker is still alive
                    else:
                        print(attacker['Name'], 'is alive')
                # if defender's hit point is smaller than attacker's Dexterity point, defender missed
                else:
                    print(defender['Name'], 'missed', attacker['Name'], 'is alive')

        # if attacker's hit point is smaller than defender's Dexterity point, attacker missed
        else:
            # defender then get the chance to roll die once to determine hit point to fightback attacker
            defender_roll = roll_die(1, 20)
            print(attacker['Name'], 'missed')
            print(defender['Name'], 'is going to attack now by', defender_roll)

            # if defender's hit point is bigger than the attacker's dexterity point
            # defender's hit point will be subtracted from the attacker's current HP
            if defender_roll > attacker['Dexterity']:
                attacker['HP'][1] -= defender_roll

                # when attacker's current HP falls below zero, attacker is died
                if attacker['HP'][1] <= 0:
                    print(attacker['Name'], 'is dead')
                    attacker['HP'][1] = 0

                # when defender's current HP is larger than zero, attacker is still alive
                else:
                    print(attacker['Name'], 'is alive')

            # if defender's hit point is smaller than attacker's Dexterity point, defender missed
            else:
                print(defender['Name'], 'missed', attacker['Name'], 'still alive')


def main():
    """
    Initiate the text-based Dungeons and Dragons game.

    :return: the result of one round of the text-based Dungeons and Dragons game.
    """
    # ask player to enter the number of syllables they desired for their game character's name
    syllables = int(input("Please select the number of syllables for their characterâ€™s name: "))
    # pass the syllables to create_character function to create a character in the game
    character = create_character(syllables)

    # print the states of the generated character
    print_character(character)
    # ask the player to equip themselves
    choose_inventory(character)
    # print the states of the modified character
    print_character(character)

    print('')
    # create an opponent character
    the_greatest_villain_of_all_time = {
        'Name': 'Loki',
        'Strength': 5,
        'Intelligence': 20,
        'Wisdom': 20,
        'Dexterity': 6,
        'Constitution': 20,
        'Charisma': 6,
        'inventory': ['The Scepter'],
        'experience points': 0,
        'class': 'sorcerer',
        'Race': 'the Frost Giants in Jotunheim',
        'HP': [20, 20]
    }
    # print the state of the opponent character
    print('\n   Your opponent is: ')
    print_character(the_greatest_villain_of_all_time)
    print('\n   In combat:')
    # generate one round of combat between player character and opponent character
    combat_round(character, the_greatest_villain_of_all_time)
    # print the states of player character and opponent character after one round of combat
    print('\n   After one round of combat: ')
    print_character(character)
    print('')
    print_character(the_greatest_villain_of_all_time)

    doctest.testmod()


if __name__ == "__main__":
    main()
